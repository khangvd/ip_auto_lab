{##### From the input variables generates a validation file (expected state) used by custom_validate to validate actual state #####}


{########## This section validates the fabric, so the configuration as applied from the the fabric.yml by fabric role #########}
cmds:
  - show ip ospf neighbors detail:
{% if bse.device_name.spine in inventory_hostname %}
{% for x in groups[bse.device_name.leaf.split('-')[-1].lower()] + groups[bse.device_name.border.split('-')[-1].lower()] %}
      {{ hostvars[x].intf_lp[0].ip |ipaddr('address') }}:
        state: FULL
{% endfor %} {% else %}
{% for x in groups[bse.device_name.spine.split('-')[-1].lower()] %}
      {{ hostvars[x].intf_lp[0].ip |ipaddr('address') }}:
        state: FULL
{% endfor %}
{# MLAG peering for leaf and border got based on odd/even hostname and +/- 1 #}
{% if inventory_hostname[-2:]|int is odd %}
      {{ intf_lp[0].ip |ipaddr('address') | ipmath(+1) }}:
        state: FULL
{% else %}
      {{ intf_lp[0].ip |ipaddr('address') | ipmath(-1) }}:
        state: FULL
 {% endif %}

  - show port-channel summary:
      {{ fbc.adv.bse_intf.ec_fmt + fbc.adv.mlag.peer_po |string }}:
        oper_status: U
        members:
          _mode: strict
          {{ fbc.adv.bse_intf.intf_fmt + fbc.adv.bse_intf.mlag_peer.split('-')[0] }}:
            mbr_status: P
          {{ fbc.adv.bse_intf.intf_fmt + fbc.adv.bse_intf.mlag_peer.split('-')[1] }}:
            mbr_status: P

  - show vpc:
      vpc_peer_keepalive_status: peer-alive
      vpc_peer_status: peer-ok #}
{% endif %}


{########## This section validates mainly configuration applied by services rrole from services_tentant.yml #########}
{#### Logic to decide which set of variables in flt_svc_tnt to render dependant on device-role ####}
{% if bse.device_name.leaf in inventory_hostname %}{% set flt_vars = flt_svc_tnt[0] %}
{% elif bse.device_name.border in inventory_hostname %}{% set flt_vars = flt_svc_tnt[1] %}
{% endif %}


{##### Validates interfaces in default and mgmt VRFs created from fabric.yml #####}
  - show ip int brief include-secondary vrf all:
      management:
        mgmt0:
          prefix: {{ ansible_host }}
          proto-state: up
          link-state: up
          admin-state: up
      default:
{# Creates template for all loopbacks (including secondary mlag ip) and interfces in default VRF #}
{%for intf in intf_lp + intf_fbc.keys() | list %}{% if intf.ip is defined %}
        {{ intf.name | replace('loopback','Lo') }}:
{# Strict mode so only the L3 mgmt, loopbacks, L&S uplinks and MLAGs can exist #}
          _mode: strict
{% if intf.mlag_lp_addr is defined %}
          prefix: {{ intf.ip |ipaddr('address'), intf.mlag_lp_addr |ipaddr('address') }}
{% else %}
          prefix: {{ intf.ip |ipaddr('address') }}
{% endif %}{% else %}
        {{ intf | replace('Ethernet','Eth') }}:
          prefix: None
{% endif %}
          proto-state: up
          link-state: up
          admin-state: up
{% endfor %}

{# The rest of the actions are only performed on the leaf and border switches #}
{% if bse.device_name.spine not in inventory_hostname %}
        Vlan{{ fbc.adv.mlag.peer_vlan }}:
          prefix: {{ mlag_peer_ip |ipaddr('address') }}
          proto-state: up
          link-state: up
          admin-state: up


{##### Validates interfaces in tenant VRFs created from services_tenant.yml #####}
{% for flt_tnt in flt_vars %}{% if flt_tnt.l3_tnt is sameas true %}
      {{ flt_tnt.tnt_name }}:
{# Strict mode so only the L3 SVIs (L3VNI has no iP) in the service_tenants can exist #}
        _mode: strict
{% for vl in flt_tnt.vlans %}
{% if vl.ip_addr == 'l3_vni' or vl.ip_addr |ipaddr('address') != False %}
        Vlan{{ vl.num }}:
{% if vl.ip_addr != 'l3_vni' %}
          prefix: {{ vl.ip_addr |ipaddr('address') }}
{% endif %}
          proto-state: up
          link-state: up
          admin-state: up
{% endif %}{% endfor %}{% endif %}{% endfor %}


{##### Validates NVE peers using VTEP loopback info from fabric.yml #####}
  - show nve peers:
{% for host in groups[bse.device_name.leaf.split('-')[-1].lower()] + groups[bse.device_name.border.split('-')[-1].lower()] %}
{# Gets VTEP loopbacks for all devices except own #}
{% if host != inventory_hostname %}
      {{ hostvars[host].intf_lp[1].ip |ipaddr('address') }}:
        peer-state: Up
{# Secondary IP is shared so only need off one in VPC pair (odd numbered device), also not this devices pair #}
{% if host[-2:]|int is odd %}{% if hostvars[host].intf_lp[1].mlag_lp_addr != hostvars[inventory_hostname].intf_lp[1].mlag_lp_addr %}
      {{ hostvars[host].intf_lp[1].mlag_lp_addr |ipaddr('address') }}:
        peer-state: Up
{% endif %}{% endif %}{% endif %}{% endfor %}


{##### Validates VNIs are created and if L3/L2 mapped to correct tenant/vlan  #####}
  - show nve vni:
      _mode: strict
{% for flt_tnt in flt_vars %}{% for vl in flt_tnt.vlans %}
{% if vl.ip_addr != 'l3_vni' %}
      "{{ vl.vni }}":
        type: L2 [{{ vl.num }}]
        state: Up
{% endif %}{% if flt_tnt.l3_tnt is sameas true and vl.ip_addr == 'l3_vni' %}
      "{{ vl.vni }}":
        type: L3 [{{ flt_tnt.tnt_name }}]
        state: Up
{% endif %}{% endfor %}{% endfor %}
{% endif %}